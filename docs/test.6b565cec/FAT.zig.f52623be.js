var data = {lines:[
{"lineNum":"    1","line":"const std = @import(\"std\");"},
{"lineNum":"    2","line":"const lib = @import(\"../lib.zig\");"},
{"lineNum":"    3","line":"const Reader = lib.Reader;"},
{"lineNum":"    4","line":"const assert = std.debug.assert;"},
{"lineNum":"    5","line":"const Allocator = std.mem.Allocator;"},
{"lineNum":"    6","line":"const log = std.log.scoped(.fat);"},
{"lineNum":"    7","line":"const set_fields_alignment = lib.set_fields_alignment;"},
{"lineNum":"    8","line":""},
{"lineNum":"    9","line":"fn join(a: anytype, b: @TypeOf(a)) @TypeOf(a) {"},
{"lineNum":"   10","line":"    var res: [a.len + b.len]std.meta.Child(@TypeOf(a)) = undefined;"},
{"lineNum":"   11","line":"    @memcpy(res[0..a.len], a);"},
{"lineNum":"   12","line":"    @memcpy(res[a.len..], b);"},
{"lineNum":"   13","line":"    return &res;"},
{"lineNum":"   14","line":"}"},
{"lineNum":"   15","line":""},
{"lineNum":"   16","line":"fn BootSectorImpl() type {"},
{"lineNum":"   17","line":"    const fields = std.meta.fields;"},
{"lineNum":"   18","line":"    var fs = join(fields(BS_Part1), fields(BIOSParameterBlock));"},
{"lineNum":"   19","line":"    fs = join(fs, fields(BS_Part2));"},
{"lineNum":"   20","line":"    // set all fields alignment to 1 (get rid of padding like #pragma pack)"},
{"lineNum":"   21","line":"    fs = set_fields_alignment(fs, 1);"},
{"lineNum":"   22","line":""},
{"lineNum":"   23","line":"    const declarations = std.meta.declarations;"},
{"lineNum":"   24","line":"    var decls = join(declarations(BS_Part1), declarations(BIOSParameterBlock));"},
{"lineNum":"   25","line":"    decls = join(decls, declarations(BS_Part2));"},
{"lineNum":"   26","line":""},
{"lineNum":"   27","line":"    return @Type(.{"},
{"lineNum":"   28","line":"        .@\"struct\" = .{"},
{"lineNum":"   29","line":"            .layout = .@\"extern\","},
{"lineNum":"   30","line":"            .backing_integer = null,"},
{"lineNum":"   31","line":"            .fields = fs,"},
{"lineNum":"   32","line":"            .decls = decls,"},
{"lineNum":"   33","line":"            .is_tuple = false,"},
{"lineNum":"   34","line":"        }"},
{"lineNum":"   35","line":"    });"},
{"lineNum":"   36","line":"}"},
{"lineNum":"   37","line":""},
{"lineNum":"   38","line":"const BS_Part1 = extern struct {"},
{"lineNum":"   39","line":"    /// Starts at offset: 0"},
{"lineNum":"   40","line":"    ///"},
{"lineNum":"   41","line":"    /// What this forms is a three-byte Intel x86"},
{"lineNum":"   42","line":"    /// unconditional branch (jump) instruction that jumps"},
{"lineNum":"   43","line":"    /// to the start of the operating system bootstrap code."},
{"lineNum":"   44","line":"    /// This code typically occupies the rest of sector 0 of"},
{"lineNum":"   45","line":"    /// the volume following the BPB and possibly other"},
{"lineNum":"   46","line":"    /// sectors."},
{"lineNum":"   47","line":"    ///"},
{"lineNum":"   48","line":"    /// Two valid options for this field are:"},
{"lineNum":"   49","line":"    ///"},
{"lineNum":"   50","line":"    /// jmp_boot[0] = 0xEB, jmp_boot[1] = 0x??,"},
{"lineNum":"   51","line":"    /// jmp_boot[2] = 0x90"},
{"lineNum":"   52","line":"    /// and"},
{"lineNum":"   53","line":"    /// jmp_boot[0] = 0xE9, jmp_boot[1] = 0x??,"},
{"lineNum":"   54","line":"    /// jmp_boot[2] = 0x??"},
{"lineNum":"   55","line":"    jmp_boot: [3]u8,"},
{"lineNum":"   56","line":"    oem_name: [8]u8,"},
{"lineNum":"   57","line":"};"},
{"lineNum":"   58","line":""},
{"lineNum":"   59","line":"/// Fields start from byte offset 11"},
{"lineNum":"   60","line":"const BIOSParameterBlock = extern struct {"},
{"lineNum":"   61","line":"    /// Count of bytes per sector. This value may take on"},
{"lineNum":"   62","line":"    /// only the following values: 512, 1024, 2048 or 4096"},
{"lineNum":"   63","line":"    bytes_per_sector: u16,"},
{"lineNum":"   64","line":""},
{"lineNum":"   65","line":"    /// Number of sectors per allocation unit. This value"},
{"lineNum":"   66","line":"    /// must be a power of 2 that is greater than 0. The"},
{"lineNum":"   67","line":"    /// legal values are 1, 2, 4, 8, 16, 32, 64, and 128."},
{"lineNum":"   68","line":"    sectors_per_cluster: u8,"},
{"lineNum":"   69","line":""},
{"lineNum":"   70","line":"    /// Number of reserved sectors in the reserved region"},
{"lineNum":"   71","line":"    /// of the volume starting at the first sector of the"},
{"lineNum":"   72","line":"    /// volume. This field is used to align the start of the"},
{"lineNum":"   73","line":"    /// data area to integral multiples of the cluster size"},
{"lineNum":"   74","line":"    /// with respect to the start of the partition/media."},
{"lineNum":"   75","line":"    ///"},
{"lineNum":"   76","line":"    /// This field must not be 0 and can be any non-zero"},
{"lineNum":"   77","line":"    /// value."},
{"lineNum":"   78","line":"    ///"},
{"lineNum":"   79","line":"    /// This field should typically be used to align the start"},
{"lineNum":"   80","line":"    /// of the data area (cluster #2) to the desired"},
{"lineNum":"   81","line":"    /// alignment unit, typically cluster size."},
{"lineNum":"   82","line":"    reserved_sector_count: u16,"},
{"lineNum":"   83","line":""},
{"lineNum":"   84","line":"    /// The count of file allocation tables (FATs) on the"},
{"lineNum":"   85","line":"    /// volume. A value of 2 is recommended although a"},
{"lineNum":"   86","line":"    /// value of 1 is acceptable."},
{"lineNum":"   87","line":"    num_of_fats: u8,"},
{"lineNum":"   88","line":""},
{"lineNum":"   89","line":"    /// For FAT12 and FAT16 volumes, this field contains"},
{"lineNum":"   90","line":"    /// the count of 32-byte directory entries in the root"},
{"lineNum":"   91","line":"    /// directory. For FAT32 volumes, this field must be set"},
{"lineNum":"   92","line":"    /// to 0. For FAT12 and FAT16 volumes, this value"},
{"lineNum":"   93","line":"    /// should always specify a count that when multiplied"},
{"lineNum":"   94","line":"    /// by 32 results in an even multiple of bytes_per_sector."},
{"lineNum":"   95","line":"    root_entries_count: u16,"},
{"lineNum":"   96","line":""},
{"lineNum":"   97","line":"    /// This field is the old 16-bit total count of sectors on"},
{"lineNum":"   98","line":"    /// the volume. This count includes the count of all"},
{"lineNum":"   99","line":"    /// sectors in all four regions of the volume."},
{"lineNum":"  100","line":"    /// This field can be 0; if it is 0, then BPB_TotSec32"},
{"lineNum":"  101","line":"    /// must be non-zero. For FAT32 volumes, this field"},
{"lineNum":"  102","line":"    /// must be 0."},
{"lineNum":"  103","line":"    /// For FAT12 and FAT16 volumes, this field contains"},
{"lineNum":"  104","line":"    /// the sector count, and BPB_TotSec32 is 0 if the"},
{"lineNum":"  105","line":"    /// total sector count “fits” (is less than 0x10000)"},
{"lineNum":"  106","line":"    total_sectors_16: u16,"},
{"lineNum":"  107","line":""},
{"lineNum":"  108","line":"    /// The legal values for this field are 0xF0, 0xF8, 0xF9,"},
{"lineNum":"  109","line":"    /// 0xFA, 0xFB, 0xFC, 0xFD, 0xFE, and 0xFF."},
{"lineNum":"  110","line":"    /// 0xF8 is the standard value for “fixed” (non-removable)"},
{"lineNum":"  111","line":"    /// media. For removable media, 0xF0 is"},
{"lineNum":"  112","line":"    /// frequently used."},
{"lineNum":"  113","line":"    media: u8,"},
{"lineNum":"  114","line":""},
{"lineNum":"  115","line":"    fat_size_16: u16,"},
{"lineNum":"  116","line":""},
{"lineNum":"  117","line":"    sectors_per_track: u16,"},
{"lineNum":"  118","line":""},
{"lineNum":"  119","line":"    num_of_heads: u16,"},
{"lineNum":"  120","line":""},
{"lineNum":"  121","line":"    hidden_sectors: u32,"},
{"lineNum":"  122","line":""},
{"lineNum":"  123","line":"    total_sectors_32: u32,"},
{"lineNum":"  124","line":""},
{"lineNum":"  125","line":"    fat_size_32: u32,"},
{"lineNum":"  126","line":""},
{"lineNum":"  127","line":"    extra_flags: u16,"},
{"lineNum":"  128","line":""},
{"lineNum":"  129","line":"    /// Must be 0, but high byte is major revision number."},
{"lineNum":"  130","line":"    /// Low byte is minor revision number."},
{"lineNum":"  131","line":"    filesystem_version: u16,"},
{"lineNum":"  132","line":""},
{"lineNum":"  133","line":"    root_cluster: u32,"},
{"lineNum":"  134","line":""},
{"lineNum":"  135","line":"    fsinfo_sector_number: u16,"},
{"lineNum":"  136","line":""},
{"lineNum":"  137","line":"    backup_boot_sector_number: u16,"},
{"lineNum":"  138","line":""},
{"lineNum":"  139","line":"    reserved: [12]u8,"},
{"lineNum":"  140","line":"};"},
{"lineNum":"  141","line":""},
{"lineNum":"  142","line":"const BS_Part2 = extern struct {"},
{"lineNum":"  143","line":"    /// IMPORTANT: FIELDS CONTINUE AT BYTE OFFSET 64 FOR FAT32"},
{"lineNum":"  144","line":"    drive_number: u8,"},
{"lineNum":"  145","line":"    reserved_1: u8,"},
{"lineNum":"  146","line":"    boot_signature: u8,"},
{"lineNum":"  147","line":"    volume_serial_number: u32,"},
{"lineNum":"  148","line":"    volume_label: [11]u8,"},
{"lineNum":"  149","line":"    file_system_type: [8]u8,"},
{"lineNum":"  150","line":"    reserved_2: [420]u8,"},
{"lineNum":"  151","line":"    signature_word: [2]u8,"},
{"lineNum":"  152","line":"    // all remaining bytes in the sector from byte offset 512 should be 0x00"},
{"lineNum":"  153","line":"    // if bytes_per_sector > 512"},
{"lineNum":"  154","line":"};"},
{"lineNum":"  155","line":""},
{"lineNum":"  156","line":"pub const FAT32Dir = extern struct {"},
{"lineNum":"  157","line":"    /// \'Short\' file name limited to 11 character"},
{"lineNum":"  158","line":"    name: [11]u8,"},
{"lineNum":"  159","line":""},
{"lineNum":"  160","line":"    /// The upper two bits of the attribute byte are reserved"},
{"lineNum":"  161","line":"    /// and must always be set to 0 when a file is created."},
{"lineNum":"  162","line":"    /// These bits are not interpreted."},
{"lineNum":"  163","line":"    attr: Attributes,"},
{"lineNum":"  164","line":""},
{"lineNum":"  165","line":"    /// Reserved. Must be set to 0."},
{"lineNum":"  166","line":"    ntres: u8,"},
{"lineNum":"  167","line":""},
{"lineNum":"  168","line":"    /// Component of the file creation time. Count of"},
{"lineNum":"  169","line":"    /// tenths of a second. Valid range is:"},
{"lineNum":"  170","line":"    /// 0 <= crt_time_tenth <= 199"},
{"lineNum":"  171","line":"    crt_time_tenth: u8,"},
{"lineNum":"  172","line":""},
{"lineNum":"  173","line":"    /// Creation time. Granularity is 2 seconds."},
{"lineNum":"  174","line":"    crt_time: u16,"},
{"lineNum":"  175","line":""},
{"lineNum":"  176","line":"    /// Creation date."},
{"lineNum":"  177","line":"    crt_date: u16,"},
{"lineNum":"  178","line":""},
{"lineNum":"  179","line":"    /// Last access date. Last access is defined as a"},
{"lineNum":"  180","line":"    /// read or write operation performed on the"},
{"lineNum":"  181","line":"    /// file/directory described by this entry."},
{"lineNum":"  182","line":"    lst_acc_date: u16,"},
{"lineNum":"  183","line":""},
{"lineNum":"  184","line":"    /// High word of first data cluster number for"},
{"lineNum":"  185","line":"    /// file/directory described by this entry."},
{"lineNum":"  186","line":"    fst_clus_hi: u16,"},
{"lineNum":"  187","line":""},
{"lineNum":"  188","line":"    /// Last modification (write) time."},
{"lineNum":"  189","line":"    wrt_time: u16,"},
{"lineNum":"  190","line":""},
{"lineNum":"  191","line":"    /// Last modification (write) date."},
{"lineNum":"  192","line":"    wrt_date: u16,"},
{"lineNum":"  193","line":""},
{"lineNum":"  194","line":"    /// Low word of first data cluster number for"},
{"lineNum":"  195","line":"    /// file/directory described by this entry."},
{"lineNum":"  196","line":"    fst_clus_lo: u16,"},
{"lineNum":"  197","line":""},
{"lineNum":"  198","line":"    /// 32-bit quantity containing size in bytes of"},
{"lineNum":"  199","line":"    /// file/directory described by this entry."},
{"lineNum":"  200","line":"    file_size: u32,"},
{"lineNum":"  201","line":""},
{"lineNum":"  202","line":"    pub const Attributes = enum(u8) {"},
{"lineNum":"  203","line":"        READ_ONLY = 0x01,"},
{"lineNum":"  204","line":"        HIDDEN    = 0x02,"},
{"lineNum":"  205","line":"        SYSTEM    = 0x04,"},
{"lineNum":"  206","line":"        VOLUME_ID = 0x08,"},
{"lineNum":"  207","line":"        DIRECTORY = 0x10,"},
{"lineNum":"  208","line":"        ARCHIVE   = 0x20,"},
{"lineNum":"  209","line":"        LONG_NAME = 0x01 | 0x02 | 0x04 | 0x08,"},
{"lineNum":"  210","line":"    };"},
{"lineNum":"  211","line":"};"},
{"lineNum":"  212","line":""},
{"lineNum":"  213","line":"pub const FAT32State = union(enum) {"},
{"lineNum":"  214","line":"    /// 0x0000000"},
{"lineNum":"  215","line":"    free,"},
{"lineNum":"  216","line":""},
{"lineNum":"  217","line":"    /// holds cluster number of the next used cluster"},
{"lineNum":"  218","line":"    /// for allocated file TODO: verify if true"},
{"lineNum":"  219","line":"    ///"},
{"lineNum":"  220","line":"    /// 0x0000002 to MAX, MAX = Maximum Valid Cluster Number"},
{"lineNum":"  221","line":"    allocated: usize,"},
{"lineNum":"  222","line":""},
{"lineNum":"  223","line":"    /// (MAX + 1) to 0xFFFFFF6"},
{"lineNum":"  224","line":"    reserved,"},
{"lineNum":"  225","line":""},
{"lineNum":"  226","line":"    /// 0xFFFFFF7"},
{"lineNum":"  227","line":"    bad,"},
{"lineNum":"  228","line":""},
{"lineNum":"  229","line":"    /// could be interpreted as EOF"},
{"lineNum":"  230","line":"    ///"},
{"lineNum":"  231","line":"    /// 0xFFFFFF8 to 0xFFFFFFE"},
{"lineNum":"  232","line":"    reserved_dont_use,"},
{"lineNum":"  233","line":""},
{"lineNum":"  234","line":"    /// 0xFFFFFFFF"},
{"lineNum":"  235","line":"    eof,"},
{"lineNum":"  236","line":"};"},
{"lineNum":"  237","line":""},
{"lineNum":"  238","line":"pub const FileAllocationTable = struct {"},
{"lineNum":"  239","line":"    state: FAT32State,"},
{"lineNum":"  240","line":"};"},
{"lineNum":"  241","line":""},
{"lineNum":"  242","line":"/// All fields are sequential on disk from byte offset 0"},
{"lineNum":"  243","line":"pub const BootSector = BootSectorImpl();"},
{"lineNum":"  244","line":""},
{"lineNum":"  245","line":"gpa: Allocator,"},
{"lineNum":"  246","line":"reader: Reader,"},
{"lineNum":"  247","line":"buf: []u8,"},
{"lineNum":"  248","line":"filesystem: []u8,"},
{"lineNum":"  249","line":"boot_sector: *BootSector,"},
{"lineNum":"  250","line":"count_of_clusters: usize,"},
{"lineNum":"  251","line":"fat: []FileAllocationTable,"},
{"lineNum":"  252","line":""},
{"lineNum":"  253","line":"const Self = @This();"},
{"lineNum":"  254","line":"const SECTOR_SIZE = 512;"},
{"lineNum":"  255","line":"const BPB_START_OFFSET = 11;"},
{"lineNum":"  256","line":"const BPB_END_OFFSET = 64;"},
{"lineNum":"  257","line":"const SIZE_OF_BPB = BPB_END_OFFSET - BPB_START_OFFSET;"},
{"lineNum":"  258","line":"const FIRST_PART_SIZE = 3 + 8;"},
{"lineNum":"  259","line":"const SECOND_PART_OFFSET = 64;"},
{"lineNum":"  260","line":"const SECOND_PART_SIZE = 448;"},
{"lineNum":"  261","line":"const INPUT_MEM_SIZE = SECOND_PART_OFFSET + SECOND_PART_SIZE;"},
{"lineNum":"  262","line":""},
{"lineNum":"  263","line":"pub const Error ="},
{"lineNum":"  264","line":"    Allocator.Error"},
{"lineNum":"  265","line":"    || std.fs.File.ReadError"},
{"lineNum":"  266","line":"    || error{"},
{"lineNum":"  267","line":"        NotFAT32,"},
{"lineNum":"  268","line":"        InvalidJmpBoot,"},
{"lineNum":"  269","line":"        FileTooSmall,"},
{"lineNum":"  270","line":"        TooLittleMemoryPassedForBootSecParsing,"},
{"lineNum":"  271","line":"        TooLittleMemoryPassedForBIOSParamBlockParsing,"},
{"lineNum":"  272","line":"    };"},
{"lineNum":"  273","line":""},
{"lineNum":"  274","line":"pub fn estimate(alloc: Allocator, reader: *Reader) f32 {","class":"lineCov","hits":"2","order":"193","possible_hits":"2",},
{"lineNum":"  275","line":"    _ = alloc;"},
{"lineNum":"  276","line":"    _ = reader;"},
{"lineNum":"  277","line":"    return 0;","class":"lineCov","hits":"1","order":"194","possible_hits":"1",},
{"lineNum":"  278","line":"}"},
{"lineNum":"  279","line":""},
{"lineNum":"  280","line":"pub fn init(gpa: Allocator, reader: *Reader) Error!Self {","class":"lineCov","hits":"2","order":"124","possible_hits":"2",},
{"lineNum":"  281","line":"    const buf = try gpa.alloc(u8, 10000);","class":"lineCov","hits":"1","order":"125","possible_hits":"1",},
{"lineNum":"  282","line":"    errdefer gpa.free(buf);","class":"linePartCov","hits":"1","order":"135","possible_hits":"4",},
{"lineNum":"  283","line":"    const read = try reader.read(buf);","class":"lineCov","hits":"1","order":"126","possible_hits":"1",},
{"lineNum":"  284","line":"    // should at least have 9 sectors of 512 bytes each"},
{"lineNum":"  285","line":"    if (read <= 9*SECTOR_SIZE) return error.FileTooSmall;","class":"lineCov","hits":"2","order":"134","possible_hits":"2",},
{"lineNum":"  286","line":"    const mem = buf[0..read];","class":"lineCov","hits":"3","order":"591","possible_hits":"3",},
{"lineNum":"  287","line":""},
{"lineNum":"  288","line":"    const bs = try parse_boot_sector(gpa, mem[0..@sizeOf(BootSector)]);","class":"linePartCov","hits":"2","order":"592","possible_hits":"3",},
{"lineNum":"  289","line":"    errdefer gpa.destroy(bs);","class":"lineNoCov","hits":"0","possible_hits":"2",},
{"lineNum":"  290","line":""},
{"lineNum":"  291","line":"    const root_dir_sectors = ((bs.root_entries_count * 32) + (bs.bytes_per_sector - 1)) / bs.bytes_per_sector;","class":"lineCov","hits":"2","order":"601","possible_hits":"2",},
{"lineNum":"  292","line":"    const fat_size = bs.fat_size_32;","class":"lineCov","hits":"1","order":"602","possible_hits":"1",},
{"lineNum":"  293","line":"    const total_sectors = bs.total_sectors_32;","class":"lineCov","hits":"1","order":"603","possible_hits":"1",},
{"lineNum":"  294","line":"    const data_sectors = total_sectors - (bs.reserved_sector_count + (bs.num_of_fats * fat_size) + root_dir_sectors);","class":"linePartCov","hits":"1","order":"604","possible_hits":"2",},
{"lineNum":"  295","line":"    const count_of_clusters = data_sectors / bs.sectors_per_cluster;","class":"lineCov","hits":"2","order":"605","possible_hits":"2",},
{"lineNum":"  296","line":"    if (root_dir_sectors != 0 or count_of_clusters < 65526) return error.NotFAT32;","class":"linePartCov","hits":"2","order":"606","possible_hits":"3",},
{"lineNum":"  297","line":""},
{"lineNum":"  298","line":"    var self: Self = .{","class":"lineCov","hits":"1","order":"607","possible_hits":"1",},
{"lineNum":"  299","line":"        .gpa = gpa,"},
{"lineNum":"  300","line":"        .reader = reader.*,"},
{"lineNum":"  301","line":"        .buf = buf[0..],","class":"lineCov","hits":"3","order":"608","possible_hits":"3",},
{"lineNum":"  302","line":"        .filesystem = mem,"},
{"lineNum":"  303","line":"        .boot_sector = bs,"},
{"lineNum":"  304","line":"        .count_of_clusters = count_of_clusters,"},
{"lineNum":"  305","line":"        .fat = undefined,"},
{"lineNum":"  306","line":"    };"},
{"lineNum":"  307","line":"    self.fat = try self.parse_fat();","class":"linePartCov","hits":"1","order":"609","possible_hits":"3",},
{"lineNum":"  308","line":"    return self;","class":"lineCov","hits":"1","order":"621","possible_hits":"1",},
{"lineNum":"  309","line":"}"},
{"lineNum":"  310","line":""},
{"lineNum":"  311","line":"pub fn deinit(self: *Self) void {","class":"lineCov","hits":"2","order":"636","possible_hits":"2",},
{"lineNum":"  312","line":"    self.gpa.free(self.buf);","class":"lineCov","hits":"1","order":"637","possible_hits":"1",},
{"lineNum":"  313","line":"    self.gpa.destroy(self.boot_sector);","class":"lineCov","hits":"1","order":"638","possible_hits":"1",},
{"lineNum":"  314","line":"    self.* = undefined;","class":"lineCov","hits":"1","order":"639","possible_hits":"1",},
{"lineNum":"  315","line":"}"},
{"lineNum":"  316","line":""},
{"lineNum":"  317","line":"fn parse_boot_sector(gpa: Allocator, mem: []u8) !*BootSector {","class":"lineCov","hits":"2","order":"593","possible_hits":"2",},
{"lineNum":"  318","line":"    if (mem.len < SECOND_PART_OFFSET + SECOND_PART_SIZE)","class":"lineCov","hits":"1","order":"594","possible_hits":"1",},
{"lineNum":"  319","line":"        return error.TooLittleMemoryPassedForBootSecParsing;","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  320","line":"    const bs = try gpa.create(BootSector);","class":"linePartCov","hits":"1","order":"595","possible_hits":"2",},
{"lineNum":"  321","line":"    errdefer gpa.destroy(bs);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  322","line":"    const dst = std.mem.asBytes(bs);","class":"lineCov","hits":"1","order":"596","possible_hits":"1",},
{"lineNum":"  323","line":"    @memcpy(dst,  mem[0..dst.len]);","class":"lineCov","hits":"2","order":"597","possible_hits":"2",},
{"lineNum":"  324","line":"    const jmp_boot = bs.jmp_boot;","class":"lineCov","hits":"1","order":"598","possible_hits":"1",},
{"lineNum":"  325","line":"    if ((jmp_boot[0] != 0xEB or jmp_boot[2] != 0x90) and jmp_boot[0] != 0xE9) return error.InvalidJmpBoot;","class":"linePartCov","hits":"2","order":"599","possible_hits":"3",},
{"lineNum":"  326","line":""},
{"lineNum":"  327","line":"    // TODO: add all validation"},
{"lineNum":"  328","line":"    return bs;","class":"lineCov","hits":"1","order":"600","possible_hits":"1",},
{"lineNum":"  329","line":"}"},
{"lineNum":"  330","line":""},
{"lineNum":"  331","line":"fn parse_fat(self: Self) ![]FileAllocationTable {","class":"lineCov","hits":"2","order":"610","possible_hits":"2",},
{"lineNum":"  332","line":"    var fat = std.ArrayList(FileAllocationTable).init(self.gpa);","class":"lineCov","hits":"1","order":"611","possible_hits":"1",},
{"lineNum":"  333","line":"    const bs = self.boot_sector;","class":"lineCov","hits":"1","order":"612","possible_hits":"1",},
{"lineNum":"  334","line":"    const s = self.find_first_sector_of_cluster(bs.root_cluster);","class":"lineCov","hits":"1","order":"613","possible_hits":"1",},
{"lineNum":"  335","line":"    _ = s;"},
{"lineNum":"  336","line":"    // log.debug(\"first sector of root cluster: {d}\", .{s});"},
{"lineNum":"  337","line":"    return try fat.toOwnedSlice();","class":"lineCov","hits":"1","order":"620","possible_hits":"1",},
{"lineNum":"  338","line":"}"},
{"lineNum":"  339","line":""},
{"lineNum":"  340","line":"fn find_first_sector_of_cluster(self: Self, cluster_num: usize) usize {","class":"lineCov","hits":"2","order":"614","possible_hits":"2",},
{"lineNum":"  341","line":"    const bs = self.boot_sector;","class":"lineCov","hits":"1","order":"615","possible_hits":"1",},
{"lineNum":"  342","line":"    const root_dir_sectors = ((bs.root_entries_count * 32) + (bs.bytes_per_sector - 1)) / bs.bytes_per_sector;","class":"lineCov","hits":"2","order":"616","possible_hits":"2",},
{"lineNum":"  343","line":"    const first_data_sector = bs.reserved_sector_count + (bs.num_of_fats * bs.fat_size_32) + root_dir_sectors;","class":"linePartCov","hits":"1","order":"617","possible_hits":"2",},
{"lineNum":"  344","line":"    const first_sector_of_cluster = ((cluster_num - 2) * bs.sectors_per_cluster) + first_data_sector;","class":"lineCov","hits":"1","order":"618","possible_hits":"1",},
{"lineNum":"  345","line":"    return first_sector_of_cluster * bs.bytes_per_sector;","class":"lineCov","hits":"1","order":"619","possible_hits":"1",},
{"lineNum":"  346","line":""},
{"lineNum":"  347","line":"}"},
{"lineNum":"  348","line":""},
{"lineNum":"  349","line":"pub fn get_backup_boot_sector(self: Self) !*BootSector {","class":"lineCov","hits":"2","order":"625","possible_hits":"2",},
{"lineNum":"  350","line":"    const mem = self.buf[6*SECTOR_SIZE..6*SECTOR_SIZE + INPUT_MEM_SIZE];","class":"lineCov","hits":"2","order":"626","possible_hits":"2",},
{"lineNum":"  351","line":"    return try parse_boot_sector(self.gpa, mem);","class":"linePartCov","hits":"1","order":"627","possible_hits":"2",},
{"lineNum":"  352","line":"}"},
{"lineNum":"  353","line":""},
{"lineNum":"  354","line":"pub fn get_size(self: Self) f64 {"},
{"lineNum":"  355","line":"    const bs = self.boot_sector;"},
{"lineNum":"  356","line":"    const root_dir_sectors = ((bs.root_entries_count * 32) + (bs.bytes_per_sector - 1)) / bs.bytes_per_sector;"},
{"lineNum":"  357","line":"    const fat_size = bs.fat_size_32;"},
{"lineNum":"  358","line":"    const total_sectors = bs.total_sectors_32;"},
{"lineNum":"  359","line":"    const data_sectors = total_sectors - (bs.reserved_sector_count + (bs.num_of_fats * fat_size) + root_dir_sectors);"},
{"lineNum":"  360","line":"    const count_of_clusters = data_sectors / bs.sectors_per_cluster;"},
{"lineNum":"  361","line":"    const s = bs.sectors_per_cluster * count_of_clusters * bs.bytes_per_sector;"},
{"lineNum":"  362","line":"    return @floatFromInt(s);"},
{"lineNum":"  363","line":"}"},
{"lineNum":"  364","line":""},
{"lineNum":"  365","line":"pub fn get_free_size(self: Self) f64 {"},
{"lineNum":"  366","line":"    _ = self;"},
{"lineNum":"  367","line":"    unreachable;"},
{"lineNum":"  368","line":"}"},
{"lineNum":"  369","line":""},
{"lineNum":"  370","line":"/// caller has to call destroy on the resulting pointer"},
{"lineNum":"  371","line":"pub fn get_root_dir(self: *Self) !*FAT32Dir {","class":"lineCov","hits":"2","order":"647","possible_hits":"2",},
{"lineNum":"  372","line":"    return try self.get_dir(self.boot_sector.root_cluster);","class":"lineCov","hits":"1","order":"648","possible_hits":"1",},
{"lineNum":"  373","line":"}"},
{"lineNum":"  374","line":""},
{"lineNum":"  375","line":"pub fn get_dir(self: *Self, cluster_number: usize) !*FAT32Dir {","class":"lineCov","hits":"2","order":"649","possible_hits":"2",},
{"lineNum":"  376","line":"    assert(cluster_number >= self.boot_sector.root_cluster);","class":"lineCov","hits":"1","order":"650","possible_hits":"1",},
{"lineNum":"  377","line":"    try self.reader.seek_to(cluster_number);","class":"lineCov","hits":"1","order":"651","possible_hits":"1",},
{"lineNum":"  378","line":"    const dir = try self.gpa.create(FAT32Dir);","class":"lineCov","hits":"1","order":"652","possible_hits":"1",},
{"lineNum":"  379","line":"    errdefer self.gpa.destroy(dir);","class":"lineNoCov","hits":"0","possible_hits":"1",},
{"lineNum":"  380","line":"    const size = @sizeOf(FAT32Dir);"},
{"lineNum":"  381","line":"    const buf: []u8 = @as([*]u8, @ptrCast(dir))[0..size];","class":"lineCov","hits":"1","order":"653","possible_hits":"1",},
{"lineNum":"  382","line":"    const read = try self.reader.read(buf);","class":"lineCov","hits":"1","order":"654","possible_hits":"1",},
{"lineNum":"  383","line":"    if (read != size) return error.DidntReadEnoughBytesForRootDir;","class":"linePartCov","hits":"1","order":"655","possible_hits":"2",},
{"lineNum":"  384","line":"    return dir;","class":"lineCov","hits":"1","order":"656","possible_hits":"1",},
{"lineNum":"  385","line":"}"},
{"lineNum":"  386","line":""},
{"lineNum":"  387","line":"test {","class":"lineCov","hits":"1","order":"69","possible_hits":"1",},
{"lineNum":"  388","line":"    std.testing.refAllDecls(Tests);","class":"lineCov","hits":"1","order":"70","possible_hits":"1",},
{"lineNum":"  389","line":"}"},
{"lineNum":"  390","line":""},
{"lineNum":"  391","line":"const Tests = struct {"},
{"lineNum":"  392","line":"    const FilesystemHandler = lib.FilesystemHandler;"},
{"lineNum":"  393","line":"    const t = std.testing;"},
{"lineNum":"  394","line":"    const t_alloc = t.allocator;"},
{"lineNum":"  395","line":"    const FAT32_PATH = \"./filesystems/fat32_filesystem.img\";"},
{"lineNum":"  396","line":"    const tlog = std.log.scoped(.fat_tests);"},
{"lineNum":"  397","line":""},
{"lineNum":"  398","line":"    test \"fresh fat32 is read as expected with all backup info in sector 6\" {","class":"lineCov","hits":"1","order":"588","possible_hits":"1",},
{"lineNum":"  399","line":"        var fs_handler: FilesystemHandler = try .init(t_alloc, FAT32_PATH);","class":"lineCov","hits":"1","order":"589","possible_hits":"1",},
{"lineNum":"  400","line":"        var fs = try fs_handler.determine_filesystem();","class":"lineCov","hits":"1","order":"590","possible_hits":"1",},
{"lineNum":"  401","line":"        defer fs_handler.deinit();","class":"linePartCov","hits":"1","order":"641","possible_hits":"4",},
{"lineNum":"  402","line":"        defer fs.deinit();","class":"linePartCov","hits":"1","order":"633","possible_hits":"4",},
{"lineNum":"  403","line":""},
{"lineNum":"  404","line":"        const fat32 = &fs.fat32;","class":"lineCov","hits":"2","order":"623","possible_hits":"2",},
{"lineNum":"  405","line":"        const bkp_bs = try fat32.get_backup_boot_sector();","class":"linePartCov","hits":"1","order":"624","possible_hits":"3",},
{"lineNum":"  406","line":"        defer t_alloc.destroy(bkp_bs);","class":"linePartCov","hits":"1","order":"632","possible_hits":"3",},
{"lineNum":"  407","line":"        const bs1_mem: []u8 = @as([*]u8, @ptrCast(fat32.boot_sector))[0..@sizeOf(BootSector)];","class":"lineCov","hits":"1","order":"628","possible_hits":"1",},
{"lineNum":"  408","line":"        const bs2_mem: []u8 = @as([*]u8, @ptrCast(bkp_bs))[0..@sizeOf(BootSector)];","class":"lineCov","hits":"1","order":"629","possible_hits":"1",},
{"lineNum":"  409","line":"        try t.expectEqualSlices(u8, bs1_mem, bs2_mem);","class":"linePartCov","hits":"1","order":"630","possible_hits":"2",},
{"lineNum":"  410","line":"        try t.expectEqualDeep(fat32.boot_sector.*, bkp_bs.*);","class":"linePartCov","hits":"2","order":"631","possible_hits":"3",},
{"lineNum":"  411","line":"    }"},
{"lineNum":"  412","line":""},
{"lineNum":"  413","line":"    test \"read root cluster\" {","class":"lineCov","hits":"1","order":"642","possible_hits":"1",},
{"lineNum":"  414","line":"        var fs_handler: FilesystemHandler = try .init(t_alloc, FAT32_PATH);","class":"lineCov","hits":"1","order":"643","possible_hits":"1",},
{"lineNum":"  415","line":"        defer fs_handler.deinit();","class":"linePartCov","hits":"1","order":"666","possible_hits":"10",},
{"lineNum":"  416","line":"        var fs = try fs_handler.determine_filesystem();","class":"linePartCov","hits":"1","order":"644","possible_hits":"2",},
{"lineNum":"  417","line":"        defer fs.deinit();","class":"linePartCov","hits":"1","order":"665","possible_hits":"9",},
{"lineNum":"  418","line":""},
{"lineNum":"  419","line":"        var fat = fs.fat32;","class":"lineCov","hits":"2","order":"645","possible_hits":"2",},
{"lineNum":"  420","line":"        const root_dir = try fat.get_root_dir();","class":"linePartCov","hits":"1","order":"646","possible_hits":"3",},
{"lineNum":"  421","line":"        defer fs_handler.alloc.destroy(root_dir);","class":"linePartCov","hits":"1","order":"664","possible_hits":"8",},
{"lineNum":"  422","line":""},
{"lineNum":"  423","line":"        try t.expect(std.mem.containsAtLeast(u8, &root_dir.name, 1, \"mkfs.fat\"));","class":"linePartCov","hits":"1","order":"657","possible_hits":"2",},
{"lineNum":"  424","line":"        // NOTE: documentation says this should always be 0, for some reason its 32"},
{"lineNum":"  425","line":"        try t.expectEqual(32, root_dir.ntres);","class":"linePartCov","hits":"2","order":"658","possible_hits":"3",},
{"lineNum":"  426","line":"        try t.expectEqual(1069875200, root_dir.file_size);","class":"linePartCov","hits":"2","order":"659","possible_hits":"3",},
{"lineNum":"  427","line":"        try t.expectEqual(0, root_dir.fst_clus_hi);","class":"linePartCov","hits":"2","order":"660","possible_hits":"3",},
{"lineNum":"  428","line":"        try t.expectEqual(0, root_dir.fst_clus_hi);","class":"linePartCov","hits":"2","order":"661","possible_hits":"3",},
{"lineNum":"  429","line":"        try t.expectEqual(0, root_dir.fst_clus_lo);","class":"linePartCov","hits":"2","order":"662","possible_hits":"3",},
{"lineNum":"  430","line":"        try t.expectEqual(.VOLUME_ID, root_dir.attr);","class":"linePartCov","hits":"2","order":"663","possible_hits":"3",},
{"lineNum":"  431","line":""},
{"lineNum":"  432","line":"        // TODO: to continue fat32 start here: figure out how to read other cluster information (had no idea on how to navigate"},
{"lineNum":"  433","line":"        // to next cluster because in read dir we seek_to(2) essentially which I don\'t understand at all)"},
{"lineNum":"  434","line":"        // for (fat.boot_sector.root_cluster+1..fat.count_of_clusters, 0..) |clus_idx, counter| {"},
{"lineNum":"  435","line":"        //     if (counter > 5) break;"},
{"lineNum":"  436","line":"        //     const dir = try fat.get_dir(clus_idx);"},
{"lineNum":"  437","line":"        //     lib.print(dir, null);"},
{"lineNum":"  438","line":"        // }"},
{"lineNum":"  439","line":"    }"},
{"lineNum":"  440","line":"};"},
]};
var percent_low = 25;var percent_high = 75;
var header = { "command" : "test", "date" : "2025-03-09 09:32:06", "instrumented" : 88, "covered" : 84,};
var merged_data = [];
